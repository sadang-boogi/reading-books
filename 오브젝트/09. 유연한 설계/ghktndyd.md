# 09. 유연한 설계

## 개방-폐쇄 원칙

> 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

- **확장에 대해 열려있다** ➡️ 애플리케이션의 요구사항이 변경될 때 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- **수정에 대해 닫혀있다** ➡️ 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

### 컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라

- **런타임 의존성**: 실행 시에 협력에 참여하는 객체들 사이의 관계
- **컴파일타임 의존성**: 코드에서 드러나는 객체들 사이의 관계

**개방-폐쇄 원칙:** 기능을 추가할 때 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 것만으로 기능 확장을 할 수 있도록 해주는 것

### 추상화가 핵심이다

> 개방-폐쇄 원칙의 핵심은 **추상화에 의존하는 것**

- **추상화:** 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법

- OCP 관점에서 생략되지 않고 남겨지는 부분은 추상화의 결과물이므로 문맥이 바뀌더라도 수정할 필요가 없어야 한다.
- 하지만 모든 설계가 수정에 대해서 폐쇄되는 것은 아니다. 변경에 의한 파급효과를 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고, 이를 추상화의 목적으로 삼아야 한다.

## 생성 사용 분리

> 유연하고 재사용 가능한 설계를 원한다면 두 가지 책임을 서로 다른 객체로 분리해야 한다. 하나는 객체를 생성하는 것이고, 다른 하나는 객체를 사용하는 것이다. **(생성과 사용을 분리)**

사용으로부터 생성을 분리하는 가장 보편적인 방법은 **객체 생성 책임을 클라이언트로 옮기는 것**
Ex) `Movie`의 클라이언트가 적절한 `DiscountPolicy` 인스턴스를 생성한 후 `Movie`에게 전달하는 것

### FACTORY 추가하기

- 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 `FACTORY` 라고 부른다.

### 순수한 가공물에게 책임 할당하기

책임 할당의 기본 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT 객체에게 할당하는 것

도메인 모델은 INFORMATION EXPERT 객체를 찾기 위한 재료이다. 하지만 `FACTORY`는 도메인 모델이 아니라 순수하게 기술적인 결정이다. 도메인과는 전혀 무관하다.

시스템을 객체로 분해하는 데는 **표현적 분해와 행위적 분해가 있다.**
표현적 분해는 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것이 목적이다.
다만 문제는 모든 책임이 도메인 객체에게 할당된다면 문제가 발생할 수 있다. 이 경우에 도메인 객체가 아닌 편의를 위해 만든 가공의 객체에게 책임을 할당해줘야 한다. 이처럼 도메인과는 무관하지만 인공적인 객체를 *
*PURE FABRICATION: 순수한 가공물**이라고 부른다.

어떤 행동을 추가하려는 데 행동을 추가할만한 객체가 없다면 PURE FABRICATION 객체를 추가하면 된다. 따라서 PURE FABRICATION은 행위적 분해에 의해 생성되는 것이 일반적이다.

## 의존성 주입

생성과 사용을 분리하면 누군가는 오롯이 사용하는 책임만 남는다. 이것은 외부의 다른 객체가 사용하는 객체에게 생성된 인스턴스를 전달해야 한다는 것을 의미한다. 이처럼 외부 객체가 인스턴스를 생성한 후 이를 전달하여
의존성을 해결하는 방법을 **의존성 주입**이라고 부른다.

- **생성자 주입**

```java
Movie avatar = new Movie("아바타", new AmountDiscountPolicy());
```

- **setter 주입**

```java
avatar.setDiscountPolicy(new AmountDiscountPolicy());
```

- **메서드 호출 주입**

```java
avatar.calculateDiscountPolicy(screening, new AmountDiscountPolicy());
```

### 숨겨진 의존성은 나쁘다

**SERVICE LOCATOR 패턴:** 의존성을 해결할 객체들을 보관하는 일종의 저장소 역할

- 외부 객체가 의존성을 전달하는 의존성 주입과 달리 SERVICE LOCATOR 패턴은 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.

하지만 위 패턴은 의존성을 구현 내부로 감추게 된다. 의존성이 감춰다면 이해하기 어렵고 디버깅하기 어렵다.
숨겨진 의존성은 캡슐화를 위반한다. 캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다.

클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화 관점에서 훌륭한 코드다.

## 의존성 역전 원칙

### 추상화와 의존성 역전

- 객체 사이에 협력이 존재할 때 그 협력의 본질은 상위 수준의 정책
- Ex) Movie와 AmountDiscountPolicy 협력의 본질은 **영화 가격 계산**이다.**영화 가격을 어떻게 계산하는지가 본질이 아니다.**

- 위 문제의 해결 방법은 **추상화**다.
- 즉 Movie는 같은 상위 수준인 DiscountPolicy와 협력해야 한다. 그래야 하위 수준의 클래스들의 변경에 유연하게 대처가 가능하다.

**정리**

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

### 의존성 역전 원칙과 패키지

객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다.
자바는 패키지를 이용해서 모듈을 구현

- 추상화를 의존하는 객체들과 같은 패키지에 모아두는 것이 좋다.
- 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.
- 위 기법은 **SEPARATED INTERFACE 패턴**이라고 한다.

**예시**

- Movie와 DisocuntPolicy를 같은 패키지에 위치
- AmountDiscountPolicy와 PercentDiscountPolicy를 같은 패키지에 위치

전통적인 패러다임: 상위 수준 모듈 ➡️ 하위 수준 모듈 (인터페이스)
객체지향 패러다임: 하위 수준 모듈 ➡️ 상위 수준 모듈 (인터페이스)

- 전통적 패러다임에서는 하위 수준이 인터페이스였지만 객체지향 패러다임에서는 상위 수준이 인터페이스

## 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

- **유연하고 재사용 가능한 설계:** 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계

유연한 설계는 단순하고 명확한 설계와는 다른 길을 걷는다. 변경하고 확장하기 쉬운 구조를 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다. (**유연한 설계는 복잡성을 수반**)

불필요한 유연성은 불필요한 복잡성을 낳는다. 단순하고 명확한 해법이 그런대로 만족스럽다면 그냥 쓰자

### 협력과 책임이 중요하다.

**설계를 유연하게 만들기 위해서는 결국에는 역할, 책임, 협력에 초점을 맞춰야 한다.**
