# 04. 설계 품질과 트레이드오프

- 객체지향 어플리케이션의 전체 품질을 결정하는 것은 **책임**이다.
- 책임을 얼마나 잘 할당하느냐가 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있는 것이다.

## 데이터 중심의 영화 예매 시스템

- **시스템을 객체로 분할하는 두 가지 방법**
    1. 상태를 분할의 중심축으로 삼는 방법
    2. 책임을 분할의 중심축으로 삼는 방법

- 상태는 데이터를 동일한 의미로 사용

- 데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다. (객체 == 독립된 데이터 덩어리)
- 책임 중심의 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 상태를 보관한다. (객체 == 협력하는 공동체의 일원)

**책임을 분할의 중심축으로 삼는 게 더 좋다.**
구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.

## 설계 트레이드오프

### 캡슐화

- **구현:** 변경될 가능성이 높은 부분
- **인터페이스:** 비교적 변경될 가능성이 낮은 부분

➡️ 객체지향 설계의 가장 기본적인 아이디어는 **변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스만 의존하도록 관계를 조절**하는 것이다.

### 응집도와 결합도

- **응집도**
    - 모듈에 포함된 내부 요소들이 연관돼 있는 정도
    - 모듈 내의 요소들이 하나의 목표를 위해 긴밀하게 협력한다면 **높은 응집도**
    - 모듈 내의 요소들이 서로 다른 목적을 추구한다면 **낮은 응집도**

- **결합도**
    - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 정도
    - 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 **높은 결합도**
    - 어떤 모듈이 다른 모듈에 대해 필요한 지식만 알고 있다면 두 모듈은 **낮은 결합도**

- **좋은 설계는 높은 응집도, 낮은 결합도**
- 좋은 설계를 잘 하려면 캡슐화가 중요하다.

## 데이터 중심의 영화 예매 시스템의 문제점

- **데이터 중심 설계의 문제점**

1. 캡슐화 위반
2. 높은 결합도
3. 낮은 응집도

### 캡슐화 위반

```java
public class Movie {

    private Money fee;

    public Money getFee() {
        return fee;
    }

    public Money setFee() {
        this.fee = fee;
    }
}
```

- 위 코드는 접근제어자가  `private` 으로 설정되어 있기 때문에 캡슐화 원칙을 잘 지키고 있는 것처럼 보인다.
- 하지만 `getter`와 `setter`는 캡슐화가 아니다.
- 왜냐하면 게터와 세터는 `Movie` 클래스 안에 `Money` 타입의 `fee`라는 이름의 인스턴스가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.

- 위처럼 접근자(getter)와 수정자(setter)에 과도하게 의존하는 설계 방식을 **추측에 의한 설계 전략**이라고 한다.
- 하지만 이 전략을 피하는 것이 좋다.

### 높은 결합도

- 객체 내부 구현이 인터페이스를 통해서 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것
    - ➡️ `fee`의 타입을 `int`로 변경하면 getFee를 호출하고 있는 클라이언트 코드들도 같이 변경되어야 한다.
- 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 발생하고 나면 시스템 전체가 요동친다.

### 낮은 응집도

- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.
- 즉 하나의 요구사항을 적용하려면 여러 모듈을 다 수정해야 한다는 것이다.
    - ➡️ 할인 정책을 추가해야 한다면?

    1. `MovieType`에 새로운 할인 정책을 추가해야 할 것이다.
    2. `ResevationAgency`의 `reserve()` 내부에 `switch-case` 를 추가해야 할 것이다.
    3. `Movie`에 새로운 할인 정책을 계산할 필드를 추가해야 할 것이다.

- 어떤 요구사항을 반영하기 위해서 **하나 이상의 클래스를 수정한다면 응집도가 낮다는 것**이다.

## 자율적인 객체를 향해

### 캡슐화를 지켜라

- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다. (접근자와 수정자는 제외)

### 스스로 자신의 데이터를 책임지는 객체

- 객체는 단순한 데이터 제공자가 아니다.
- 객체의 데이터보다 책임을 정의하는 오퍼레이션이 더 중요하다.

- 따라서 객체를 설계할 때는 아래 두 가지 질문을 조합해서 설계해야 한다.

1. `이 객체가 어떤 데이터를 포함해야 하는가?`
2. `이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?`

## 하지만 여전히 부족하다.

### 캡슐화 위반

```java
public class DiscountCondition {
    private DiscountConditionType type;
    private int sequence;
    private DatOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public DiscountCondiationType getType() {...}

    public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {...}

    public boolean isDiscountable(int sequence) {...}
}
```

- 기간 조건을 충족하는지 확인하는 `isDiscountable`을 보면 인자로 `DayofWeek`와 `LocalTime`을 받는다.
- 이는 `DiscountCondition` 객체 내부에 `DayOfWeek` 타입의 변수와 `LocalTime` 타입의 변수가 포함돼 있다는 사실을 노출하게 된다.
- 순번 조건을 충족하는지 확인하는 `isDiscountable` 역시 마찬가지다.
- 이에 대한 문제점은 만약에 `DayOfWeek` 타입을 `String` 타입으로 변경한다면 해당 메서드를 호출하고 있는 클라이언트도 모두 수정되어야 한다.

**Movie도 문제가 있다.**

```java
public class Movie {
    public Money calculateAmountDiscountedFee() {...}

    public Money calculatePercentDiscountedFee() {...}

    public Money calculateNoneDiscountedFee() {...}
}
```

- `Movie`는 영화 요금 계산을 위해서 금액 할인 정책, 비율 할인 정책, 할인 정책 없음의 경우에 호출할 수 있는 세 가지 메서드를 구현하고 있다.
- 이는 `MovieType(할인정책)`이 3개가 존재하는 것을 공개하는 것이다.
- 이에 대한 문제점은 만약 할인 정책이 추가된다면 클라이언트가 영향을 받을 것이 명백하다.

#### 캡슐화의 진정한 의미

- 캡슐화는 객체 내부의 데이터를 감추는 것 이상의 의미를 가진다.
- 즉, 변경될 수 있는 어떤 것이라도 감추는 것이 캡슐화의 진정한 의미다.
- 예를 들면 객체 속성의 타입이건 할인 정책의 종류건 말이다.

### 높은 결합도

- `Movie`의 `isDiscountable` 메서드는 `Movie` 내에 `discountConditions`을 순회하면서 할인 조건 종류에 따라서 `DiscountCondition`에 구현된
  2개의 `isDiscountable` 중에서 적절한 것을 호출한다.
- 하지만 이는 문제 발생의 소지가 높다.
  🤔: 만약 `DiscountCondition`의 기간 할인 조건의 명칭이 `PERIOD`에서 `Duration`으로 바뀐다면??
    - `Movie`의 `calculatePercentDiscountedFee` 메서드를 수정해야 한다.
      🤔: 만약 `DiscountCondition`의 종류가 늘어난다면?
    - `Movie`의 `isDiscountable`의 if 분기를 늘려야 한다.

- 여기서 주목할 것은 `Movie`의 메서드들이 `DiscountCondition`의 구현에 속한다는 사실에 주목하자. 이는 `DiscountCondition`의 구현이
  변경되어도 `DiscountCondition`에 의존 중인 `Movie`를 변경해야 한다는 것이다.
- 그리고 이렇게 구현이 변경되었을 때 의존하고 있는 다른 객체가 변경이 불가피한 것이 **결합도가 높다는 것을 의미한다.**

### 낮은 응집도

- 만약 `DiscountCondition`이 할인 여부를 판단하는 데 필요한 정보가 변경된다면? (지금은 `DayOfWeek`, `LocalTime`, `int`지만 변경 될 수 있다.)

1. `Movie`의 `isDiscountable()`의 인자들이 변경되어야 한다.
2. 이로 인해 `Screening`의 `calculateFee()` 내부에서 `movie의 isDiscountable()`을 호출하고 있는 부분도 변경되어야 한다.

- 결과적으로 할인 조건의 종류를 변경하려면 `DiscountCondition`, `Movie`, `Screening`을 모두 수정해야 한다.
- 이처럼 하나의 변경을 수용하기 위해서 코드의 여러 곳을 동시에 변경해야 한다는 것이 **응집도가 낮다는 것을 의미한다.**

## 데이터 중심 설계의 문제점

- 데이터 중심 설계는 변경에 취약하다. 그 이유는 아래 2가지다.

1. 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
2. 데이터 중심 설계는 협력을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

- "객체가 포함할 데이터가 무엇인가?" 는 캡슐화를 깨뜨린다.
- 데이터는 구현의 일부다. (구현은 외부 노출이 되면 안 된다.)
- 데이터와 기능을 분리하는 것은 **절차적 프로그래밍**
- 상태와 행동을 하나의 단위로 캡슐화 하는 것이 **객체지향 프로그래밍**
- `pulic`을 쓰는 거나 `private`를 쓰고 `getter/setter`를 쓰는 것은 큰 차이가 없다.
- 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 정의하는 것은 데이터에 관한 지식이 인터페이스에 드러나게 한다.
- 결과적으로 객체의 인터페이스는 구현을 캡슐화 하는 데 실패하고, 코드는 변경에 취약해진다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

- 객체지향 설계의 무게 중심은 내부가 아니라 외부에 맞춰져 있어야 한다.
- 데이터 중심 설계는 외부가 아니라 내부에 초점이 있기 때문에 데이터의 구현 먼저 결정한다.
- 이미 구현이 결정된 뒤에 협력을 고민하기 때문에 객체의 인터페이스에 구현을 끼워맞추게 되는 수 밖에 없다.
- 결과적으로 객체 인터페이스에 구현이 노출돼 있기 때문에 협력을 이루기 위해서는 구현이 종속될 수 밖에 없었고, 그에 따라서 내부 구현이 변경된다면 협력도 변경될 수 밖에 없던 것이다.