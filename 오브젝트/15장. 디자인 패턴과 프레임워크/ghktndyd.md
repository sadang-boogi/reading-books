# 15. 디자인 패턴과 프레임워크

**디자인 패턴:** 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법 (설계를 재사용하려는 것이 목적)

**프레임워크:** 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다. (설계 + 코드 재사용)

디자인 패턴과 프레임워크 둘 다 협력을 일관성 있게 만들어주는 도구이다.

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

- 패턴의 정의보다는 패턴이라는 용어가 풍기는 뉘앙스를 이해하는 것이 중요

**패턴이란 무엇인가?**

- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.
- 패턴은 실무에서 유용하게 사용해 왔고, 다른 실무에서도 유용할 것이라고 예상되는 아이디어다.

**패턴 시스템, 패턴 언어:** 연관된 패턴들의 집합, 패턴의 생성 규칙과 다른 패턴과의 관계 및 협력 규칙

### 패턴 분류

- 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 **아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄**의 4가지로 분류하는 것
- **디자인 패턴**이 가장 잘 알려진 패턴이고, 디자인 패턴은 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조 문제를 해결한다. (중간 규모의 패턴)
- **아키텍처 패턴**은 소프트웨어의 전체적인 구조를 결정하기 위한 패턴이고, 미리 정의된 서브시스템들을 제공하고 각 서브시스템들의 책임을 정의하며 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을
  포함한다. (상위 규모의 패턴)
- **이디엄**은 특정 프로그래밍 언어에만 국한된 패턴이고, 주어진 언어의 기능을 사용해서 컴포넌트 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다. (하위 규모의 패턴)
- **분석 패턴**은 위 3가지 패턴들은 기술적인 문제 해결의 초점이지만 도메인 내의 개념적인 문제 해결이 초점이다. 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.

### 패턴과 책임-주도 설계

- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿
- 예를 들어 **STRATEGY 패턴**은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합
- **BRIDGE 패턴**은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해하면서 설계를 확장 가능하게 만든다.
- 패턴의 구성 요소는 클래스가 아니라 **역할**이다. 이 말은 즉 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 것이다.

### 캡슐화와 디자인 패턴

- 다시 한 번 말하지만 디자인 패턴은 협력을 일관성 있고, 유연하게 만드는 것이 목적이다.

### 패턴은 출발점이다

- 패턴이 설계의 목표가 되어서는 안된다. (패턴 만능주의 조심)
- 패턴을 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것

## 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

- 디자인 패턴은 설계 재사용, 컴포넌트 재사용은 코드 재사용이지만 다양한 도메인에서 발생하는 다양한 문제를 컴포넌트 재사용으로 해결하기는 불가능했다.
- 그러면서 설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 피할 수 있는 방법이 뭐가 있을까 생각하다가 나온 것이 **프레임워크**
- **프레임워크:**
    - **프레임워크의 구조적 측면에 대해서 설명:** 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
    - **코드와 설계의 재사용 관점에서의 설명**: 개발자가 현재 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격

> [!note] 프레임워크
> - 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들간의 상호작용, 객체와 클래스의 조합 방법, 제어 흐름에 대해서 미리 정의한다.
> - 프레임워크는 설계의 가변성을 미리 정의해뒀기에 설계자나 구현자는 애플리케이션에 종속적인 부분만 구현하면 된다.
> - 프레임워크는 애플리케이션 영역에 걸쳐 공통 클래스들을 정의해서 일반적인 설계를 결정해둔다.
> - 비록 프레임워크가 즉시 업무에 투입할 수 있는 구체적인 서브클래스들을 포함하고 있지만 **프레임워크는 코드 재사용보다는 설계 자체의 재사용을 중요시한다.**

### 상위 정책과 하위 정책으로 패키지 분리하기

- 상위 정책은 하위 정책보다 더 다양한 상황에서 재사용되어야 한다.
- 상위 정책과 하위 정책 둘 다 추상화에 의존하도록 만들어야 한다.
- 프레임워크는 여러 애플리케이션에 걸쳐서 재사용 가능해야 하기 때문에 **변하는 것과 변하지 않는 것들을 서로 다른 주기에 배포할 수 있도록 '배포 단위'로 분류해야 한다.** (패키지를 서로 분리)

### 제어 역전 원리

- 상위 정책을 재사용한다는 것은 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미
- 로버트 마틴은 훌륭한 객체지향 설계는 의존성이 역전된 설계라고 한다.
- 의존성 역전이 된 구조에서는 프레임워크가 애플리케이션에 속한 서브클래스들을 호출한다. 이를 IoC 제어의 역전이라고 한다.
- 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라서 달라질 가능성이 있는 특정한 동작은 비워둔다. 그리고 이렇게 미완성된 채로 남겨진 동작을 **훅**이라고 한다.
- **훅**은 애플리케이션의 컨텍스트에 따라서 달라진다.
- 라이브러리를 사용한다면 애플리케이션이 라이브러리의 코드를 호출한다. 즉 애플리케이션이 제어권을 가진다.
- 프레임워크를 사용한다면 프레임워크가 애플리케이션의 호출을 제어한다. 제어권이 프레임워크에게 있다.
