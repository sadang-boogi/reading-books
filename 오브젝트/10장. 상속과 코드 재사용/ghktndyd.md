# 10. 상속과 코드 재사용

## 상속과 중복 코드

- 중복 코드는 작성자 뿐만 아니라 동료들을 의심하게 만든다.

### DRY 원칙

- 중복 코드의 가장 큰 문제는 코드를 수정하는 데 노력이 몇 배로 증가한다.
- 중복 여부를 판단하는 기준은 변경이다. **요구사항이 변경됐을 때 두 개의 코드가 같이 변경되어야 한다면 두 코드는 중복**이다.

> [!note] DRY 원칙
> - Don't Repear Yourself 첫 글자를 모아서 DRY이다. 번역하면 **"반복하지 마라"** 라는 뜻이다.
> - 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.

### 중복과 변경

#### 중복 코드 살펴보기 (전화 요금 계산 애플리케이션)

**요구사항**

1. 한 달에 한 번씩 가입자 별로 전화 요금을 계산
2. 전화 요금을 계산하는 규칙은 통화 시간을 단위 시간당 요금으로 나눈다.
3. Ex) 10초당 5원의 통화료 요금제에 가입돼 있는 가입자가 100초동안 통화를 했다면 **100 / 10 * 5 = 50원**
4. 통화료 = (통화한 시간) / (단위 시간) * (통화료)

#### 타입 코드 사용하기

```java
enum PhoneType {
    REGULAR, NIGHTLY
}
```

- 위 처럼 핸드폰의 타입을 분류하는 것을 열거형 타입으로 구분할 수 있다.
- 하지만 위처럼 타입을 구분한다면 낮은 응집도, 높은 결합도 문제가 생긴다.

#### 상속을 이용해서 중복 코드 제거하기

- 야간 요금제에 가입되어 있는 핸드폰 객체인 `NightDiscountPhone`가 일반 요금제 핸드폰 `Phone` 객체를 상속하면 중복 코드를 제거할 수 있다.
- 하지만 위처럼 중복을 제거한다면 코드를 해석하기가 어렵다.
- 또한 **상속은 결합도를 높인다.**

#### 강하게 결합된 Phone과 NightlyDiscountPhone

- NightDiscountPhone은 Phone의 `calculateFee()`를 오버라이딩 해야 한다.
- 만약 상속으로 중복을 제거한다면 세금을 부과하는 요구사항이 추가되었을 때
    - Phone: 필드로 taxRate(세율) 추가하고 `calculateFee()`의 반환 값에 세율을 곱해줘야 한다.
    - NightDiscountPhone: 부모의 세율도 빼줘야 한다.

➡️ 너무 강하게 결합되어 있기에 새로운 중복 코드가 발생한다.

```txt
상속을 위한 경고1
자식 클래스의 메서드 안에서 super 참조를 이용해서 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다.

때문에 super 호출을 제거할 수 있는 방법을 찾아서 결합도를 제거하라.
```

## 취약한 기반 클래스 문제

- 위에서 본 것처럼 상속은 자식 클래스와 부모 클래스의 결합도를 높인다.
- **취약한 기반 클래스 문제:** 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상 (상속 관계에서 결합도가 초래하는 문제점을 가리키는 용어)

> 핵심적인 기반 클래스에 대한 단순한 변경이 전체 프로그램을 불안정한 상태로 만들어 버릴 수도 있다.

- 취약한 기반 클래스 문제는 상속에서 결합도가 초래하는 문제
- 상속 관계는 관계가 추가될 수록 전체 시스템의 결합도가 높아진다.
- 상속이 문제되는 이유는 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들어서 캡슐화를 약화시킨다.
- 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다.
- 상속을 활용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받을 수 있다.

### 불필요한 인터페이스 상속 문제

#### 자바 초기 버전의 상속을 잘못 사용한 사례

1. `java.util.Properties`
2. `java.util.Stack`

- 두 클래스의 공통점은 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다.

**Stack**

- Vector의 자식 클래스
- Vector는 `get, add, remove`과 같은 오퍼레이션을 제공
- Stack은 `push, pop`과 같은 오퍼레이션 제공

- 여기서 문제가 발생한다. Stack은 Vector의 자식 클래스라서 Vector의 오퍼레이션을 사용이 가능한데, Stack의 특징은 LIFO를 위반하게 된다.
  **Properties**
- 키와 값 타입으로 String만 가질 수 있는 HashMap의 자식 클래스
- 여기서 HashMap은 Map의 조상인 Hashtable을 상속 받는데 여기에 있는 `put`을 사용하면 String이 아닌 타입도 Properties에 저장이 가능
- Properties의 특징인 키와 값의 타입이 String인 규칙이 위반된다.

```txt
상속을 위한 경고 2
상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
```

### 메서드 오버라이딩의 오작용 문제

- 예시: `HashSet`의 구현에 강하게 결합된 `InstrumentedHashSet` 클래스
- `InstrumentedHashSet`: `HashSet` 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 클래스이며 `HashSet`의 자식 클래스
- `addAll()` 메서드가 부모 클래스의 `add()`까지 작동시키며 예상과 다른 결과를 초래

```
상속을 위한 경고 3
자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
```

### 부모 클래스와 자식 클래스의 동시 수정 문제

- 자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 때 자식 클래스의 수정이 필요할 수 있다.
- 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 전제라서 자식 클래스가 부모 클래스의 내부에 대해서 속속들이 알도록 강요한다.

```
상속을 위한 경고 4
클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
```

## Phone 다시 살펴보기

### 추상화에 의존하자

- 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 해야 한다.

**코드 중복을 제거하기 위한 두 가지 원칙**

1. 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해서 두 메서드를 동일한 형태로 보이도록 만들 수 있다.

2. 부모 클래스의 코드를 하위로 내리지 말고, 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과
   응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

### 추상화가 핵심이다

- 공통 코드를 이동시킨 후에는 각 클래스는 서로 다른 변경의 이유를 갖게 됨
- **AbstractPhone:** 전체 통화 목록을 계산하는 방법이 바뀔 경우에만 변경된다.
- **Phone:** 일반 요금제의 통화 한 건을 계산하는 방식이 바뀔 경우에만 변경된다.
- **NightlyDiscountPhone:** 심야 요금제의 통화 한 건을 계산하는 방식이 바뀔 경우에만 변경된다.

- 세 클래스는 각각 하나의 변경 이유만을 가진다. 그렇기에 단일 책임 원칙을 준수하고 있고 결과적으로 **응집도가 높다.**
- 또한 `AbstractPhone`의 자식 클래스인 `Phone, NightlyDiscountPhone`은 부모 클래스의 구현에 의존하지 않는다.
- `calculateCallFee`의 시그니처가 변경되지 않는 한 부모 클래스의 내부 구현 변경에 영향이 없다. 결과적으로 **낮은 결합도를 유지한다.**

### 의도를 드러내는 이름 선택하기

- `Phone`이라는 이름은 `NightlyDiscountPhone`에 비해서 명확하지 않다.
- `Phone` ➡️ `RegularPhone`

### 세금 추가하기

- 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발한다. (`taxRate`)

## 차이에 의한 프로그래밍

- 상속 사용시 이미 존재하는 클래스 코드를 기반으로 다른 부분을 구현함으로써 새로운 기능을 빠르게 추가 가능
- 이처럼 기존 코드와 다른 부분만 추가하는 것을 **차이에 의한 프로그래밍**이라고 부름
- 차이에 의한 프로그래밍의 목표는 중복 제거, 코드 재사용
- 하지만 상속은 코드 재사용에서는 강력하지만 생각보다 우아한 해결 방법은 아님
- 🚀 **상속보다 합성을 사용하자.**

