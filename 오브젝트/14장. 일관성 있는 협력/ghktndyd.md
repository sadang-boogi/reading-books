# 14. 일관성 있는 협력

## 핸드폰 과금 시스템 변경하기

- 유사한 기능은 서로 다른 방식으로 구현해서는 안 된다.
- 유사한 기능은 유사한 방식으로 구현해야 한다.
- 유지보수 가능한 시스템을 구축하는 첫 걸음은 협력을 일관성 있게 만드는 것이다.

## 설계에 일관성 부여하기

- **일관성 있는 설계를 만드는 방법**
    - 다양한 설계 경험을 해보기
    - 널리 알려진 디자인패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해보기

- **협력을 일관성 있게 만들기 위한 기본 지침**
    1. 변하는 개념을 변하지 않는 개념으로부터 분리하라.
    2. 변하는 개념을 캡슐화하라.

> 바뀌는 부분을 따로 뽑아서 캡슐화한다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다.

### 조건 로직 대 객체 탐색

- 절차지향 프로그램에서 변경을 처리하는 방법은 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것
- 객체지향 프로그램에서 변경을 처리하는 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것

🤔: 조건 로직을 객체 사이의 이동으로 변경하기 위해서는?

- 커다란 클래스들을 작은 클래스들로 분리
- 분리하는 기준은 **변경의 이유**와 **주기**
- 클래스는 단 하나의 이유에 의해서만 변경돼야 하고, 하나의 클래스의 모든 크드는 함께 변경돼야 한다.
- 즉 단일책임원칙을 따라야 한다.

**핵심:** 훌륭한 추상화를 찾아서 추상화에 의존하도록 만드는 것

### 캡슐화 다시 살펴보기

- 캡슐화는 데이터 은닉 이상의 개념이다. (private으로 변수 선언하고 getter, setter로만 접근하게 하는 것 뿐만 아니라 그 이상의 개념을 담고 있다.)
- **캡슐화는 소프트웨어 안에서 변할 수 있는 모든 개념을 감추는 것**

![[Pasted image 20240624145615.png]]
**위 그림 기준 설명**

- **데이터 캡슐화:** `Movie` 클래스의 인스턴스 변수 `title`의 가시성은 `private`이라서 외부에서 직접 접근이 불가능하다.
- **메서드 캡슐화:** `DiscountPolicy` 클래스에 정의돼 있는 `getDiscountAmount` 메서드의 가시성은 `protected`다. 클래스의 외부에서는 이 메서드는 직접 불가능하고 클래스
  내부와 서브 클래스에서만 접근이 가능하다. 따라서 클래스 외부에는 영향을 미치지 않고 메서드를 수정할 수 있다. 이는 클래스의 내부 행동을 캡슐화하고 있는 것이다.
- **객체 캡슐화:** `Movie` 클래스는 `DiscountPolicy` 타입의 인스턴스 변수 `discountPolicy`를 포함한다. 이 변수는 `private`의 가시성이기 때문에 `Movie`
  와 `DiscountPolicy` 사이의 관계를 변경하더라도 외부에는 영향을 미치지 않는다. 다시 말해서 객체와 객체 사이의 관계를 캡슐화한다. **객체 캡슐화는 합성이다**
- **서브타입 캡슐화:** `Movie`는 `DiscountPolicy`는 알지만 `DiscoutPolicy`의 서브 클래스들은 모른다. 그러나 실제 실행 시점에는 서브 클래스들과 협력한다. 이것은 기반
  클래스인 `DiscountPolicy`가 서브 클래스들을 감춰주고 있기 때문에 가능하다. 다시 말해서 서브 타입의 종류를 캡슐화는 것이다. 이는 곧 **다형성의 기반이 된다. (인터페이스 상속)**

## 일관성 있는 기본 정책 구현하기

### 변경 캡슐화하기

- 변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것
- 변하는 부분의 공통점은 추상화하는 것
- 변하지 않는 부분은 추상화에만 의존하도록 관계를 제한하는 것

### 구체적인 협력 구현하기

- 현재 요금제가 시간대별 정책인지, 요일별 정책인지, 구간별 정책인지를 결정하는 것은 `FeeCondtion`을 대체하는 객체의 타입이 무엇인가에 따라 달라진다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것을 **개념적 무결성** 이라고 부름

### 협력 패턴에 맞추기

- 고정 요금은 다른 요금과 다르게 '규칙'이라는 개념이 필요 없다.
- '단위 요금' 정보만 있어도 충분하다.
- 그렇다면 고정요금 정책은 기존의 협력 방식과 다르게 구현하는 것이 최선일까?
- 정답은 아니다 가급적이면 기존 협력과 패턴을 유사하게 하는 것이 가장 좋다.

> [!note] 지속적으로 개선하라
> 처음에는 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르면서 새로운 요구사항이 추가되는 과정에서 일관성이 흐트러지는 경우를 자주 보게 된다. 협력을 설계하는 초기 단계에서 모든 요구사항을 미리 예상할 수
> 없기 때문에 이것은 잘못이 아니며 꽤나 자연스러운 현상이다. 오히려 새로운 요구사항을 수용할 수 있는 협력 패턴을 향해 설계를 진화시킬 수 있는 좋은 신호로 받아들여야 한다.
> 협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링하라. 요구사항의 변경에 따라 협력 역시 지속적으로 개선해야 한다.
> 중요한 것은 현재의 설계의 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지다.

### 패턴을 찾아라

- **일관성 있는 협력의 핵심:** 변경을 분리하고 캡슐화하는 것
- 변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정한다.
- 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후에 이 추상화에 변하지 않는 공통적인 책임을 할당하라.
- 만약 현재 구조가 변경을 캡슐화하기에 적절치 않ㄱ다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 리팩터링하라.

