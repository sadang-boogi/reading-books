# 11. 합성과 유연한 설계

- 상속은 부모 클래스와 자식 클래스의 **의존성이 컴파일 시점에 고정돼서 높은 결합도를 가짐**
- 합성은 두 객체 사이의 의존성이 **런타임 시점에 고정되어 낮은 결합도를 가짐**

**상속**

- 부모 클래스와 자식 클래스를 상속 구조로 연결
- 클래스 사이의 정적인 관계 (코드를 작성하는 시점에 변경 불가)
- **화이트박스 재사용**: 상속으로 인한 재사용을 뜻한다. 상속을 받으면 부모 클래스의 구현이 자식 클래스에게 공개되기 때문에 화이트박스라고 불림

**합성**

- 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 사용
- 부분을 표현하는 객체의 퍼블릭 인터페이스에 의존
- 클래스 사이의 동적인 관계 (런타임 시점에도 변경 가능)
- **블랙박스 재사용**: 합성으로 인한 재사용을 뜻한다. 합성 시에는 객체의 구현이 공개되지 않고 퍼블릭 인터페이스로만 재사용이 가능하기에 블랙박스라고 불림

## 상속을 합성으로 변경하기

**상속을 남발하면 직면하는 세 가지 문제점**

1. 불필요한 인터페이스 상속 문제
2. 메서드 오버라이딩 문제
3. 부모 클래스와 자식 클래스의 동시 수정 문제

#### 합성으로 변경하기 위한 과정

1. 자식 클래스에 선언된 상속 관계를 제거한다.
2. 부모 클래스의 인스턴스를 자식 클래스의 변수로 선언한다.

#### 메서드 오버라이딩 문제

- **포워딩:** 부모 클래스의 인터페이스를 그대로 외부에 제공하면서 일부 작동만 변경할 때 사용하는 방법
- **포워딩 메서드:** 동일한 메서드를 호출하기 위해서 추가된 메서드

## 상속으로 인한 조합의 폭발적인 증가

- 상속으로 인해서 결합도가 높아지면 코드 수정시 작업양이 과도하게 증가할 수 있다. (작은 기능들을 조합해서 큰 기능을 수행해야 하는 경우)
- 단일 상속만 지원하는 언어에서는 상속으로 인해 중복 코드 양이 오히려 증가할 수 있다.
- **훅 메서드:** 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 만든 것이지만 구현할 때 편의를 위해서 기본 구현은 제공하는 메서드 (왜냐하면 아예 abstract method면 처음부터
  구현해야 하는데 기본 구현이 제공되면 굳이 바꾸지 않아도 된다면 오버라이딩 하지 않아도 되니까.)