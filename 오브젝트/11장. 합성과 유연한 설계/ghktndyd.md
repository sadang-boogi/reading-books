# 11. 합성과 유연한 설계

- 상속은 부모 클래스와 자식 클래스의 **의존성이 컴파일 시점에 고정돼서 높은 결합도를 가짐**
- 합성은 두 객체 사이의 의존성이 **런타임 시점에 고정되어 낮은 결합도를 가짐**

**상속**

- 부모 클래스와 자식 클래스를 상속 구조로 연결
- 클래스 사이의 정적인 관계 (코드를 작성하는 시점에 변경 불가)
- **화이트박스 재사용**: 상속으로 인한 재사용을 뜻한다. 상속을 받으면 부모 클래스의 구현이 자식 클래스에게 공개되기 때문에 화이트박스라고 불림

**합성**

- 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 사용
- 부분을 표현하는 객체의 퍼블릭 인터페이스에 의존
- 클래스 사이의 동적인 관계 (런타임 시점에도 변경 가능)
- **블랙박스 재사용**: 합성으로 인한 재사용을 뜻한다. 합성 시에는 객체의 구현이 공개되지 않고 퍼블릭 인터페이스로만 재사용이 가능하기에 블랙박스라고 불림

## 상속을 합성으로 변경하기

**상속을 남발하면 직면하는 세 가지 문제점**

1. 불필요한 인터페이스 상속 문제
2. 메서드 오버라이딩 문제
3. 부모 클래스와 자식 클래스의 동시 수정 문제

#### 합성으로 변경하기 위한 과정

1. 자식 클래스에 선언된 상속 관계를 제거한다.
2. 부모 클래스의 인스턴스를 자식 클래스의 변수로 선언한다.

#### 메서드 오버라이딩 문제

- **포워딩:** 부모 클래스의 인터페이스를 그대로 외부에 제공하면서 일부 작동만 변경할 때 사용하는 방법
- **포워딩 메서드:** 동일한 메서드를 호출하기 위해서 추가된 메서드

## 상속으로 인한 조합의 폭발적인 증가

- 상속으로 인해서 결합도가 높아지면 코드 수정시 작업양이 과도하게 증가할 수 있다. (작은 기능들을 조합해서 큰 기능을 수행해야 하는 경우)
- 단일 상속만 지원하는 언어에서는 상속으로 인해 중복 코드 양이 오히려 증가할 수 있다.
- **훅 메서드:** 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 만든 것이지만 구현할 때 편의를 위해서 기본 구현은 제공하는 메서드 (왜냐하면 아예 abstract method면 처음부터
  구현해야 하는데 기본 구현이 제공되면 굳이 바꾸지 않아도 된다면 오버라이딩 하지 않아도 되니까)

### 객체 합성이 클래스 상속보다 더 좋은 방법이다

- 상속은 부모 클래스의 구현을 재사용하기에 부모 클래스와 자식 클래스가 강하게 결합
- 구현은 인스턴스 변수로 선언된 객체의 퍼블릭 인터페이스를 재사용하기에 비교적 약하게 결합

#### 그렇다고 상속을 쓰지 말라는 것은 아니다

- 상속은 구현 상속과 인터페이스 상속으로 나눠진다.
- 구현 상속은 단점이 많다.

## 믹스인 (사실 이해를 못 하겠음.. 💬)

- 상속과 클래스를 기반으로 하는 재사용 방법은 클래스의 확장과 수정을 일관성 있게 표현할 수 있는 추상화의 부족을 초래한다. (변경 난이도 상승)
- 해결책은 구체적인 코드를 재사용하면서도 낮은 결합도를 유지 가능한 추상화 방법을 도입하는 것
- **믹스인**: 객체를 생성할 때 코드의 일부를 클래스 안에 섞어서 재사용하는 기법이다. 합성과 다른 점은 합성은 런타임 시점에 클래스가 지정된다면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 방식이다.
