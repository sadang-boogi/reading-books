# 06. 메세지와 인터페이스

## 협력과 메시지

### 클라이언트- 서버 모델

- **클라이언트-서버 모델**은 두 객체 사이의 협력 관계를 설명하기 위한 전통적인 메타포
- 협력 안에서 메세지를 전송하는 객체를 클라이언트
- 협력 안에서 메세지를 수신하는 객체를 서버
- 협력은 **클라이언트가 서버의 서비스를 요청하는 단방향 상호작용**
- 일반적으로 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행한다.
- 협력의 관점에서 객체는 두 가지 종류의 메세지 집합으로 구성된다.
    - 객체가 수신하는 메세지의 집합
    - 외부의 객체에게 전송하는 메세지의 집합

### 메세지와 메세지 전송

- **메세지:** 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
- 메세지는 **오퍼레이션 명**과 **인자**로 구성되며 메세지 전송은 **저 2개 + 메세지 수신자**다.

### 메세지와 메서드

- 메세지를 수신했을 때 실제로 어떤 코드가 실행되는지는 수신자의 타입에 따라서 달라진다.
- 메세지를 수신했을 때 **실제로 실행되는 함수 또는 프로시저를 메서드**라고 한다.
- 메세지와 메서드의 구분 덕분에 전송자와 수신자가 느슨하게 결합이 가능

### 퍼블릭 인터페이스와 오퍼레이션

- **퍼블릭 인터페이스:** 객체가 의사소통을 위해서 외부에 공개하는 메세지의 집합
- **오퍼레이션**
    - 퍼블릭 인터페이스에 포함된 메세지
    - 수행 가능한 어떤 행동에 대한 추상화
    - 일반적으로 내부 구현은 제외하고 단순히 메세지와 관련된 시그니처만을 가르킴
- **메서드**: 메세지 수신시 실제 실행되는 코드
- 객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 오퍼레이션의 호출로 해석한다.
- 이후 메세지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아서 실행한다.

### 시그니처

- 메서드명 + 파라미터 목록 = **시그니처**

### 용어정리

- **메세지:** 객체가 다른 객체와 협력하기 위한 의사소통 메커니즘, 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 "메세지 전송"이라고 부른다. 메세지는 전송자와 수신자 모두를 포함하는 개념이다.
- **오퍼레이션:** 객체가 다른 객체에게 제공하는 추상적인 서비스. 메세지가 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 오퍼레이션은 메세지를 수신하는 객체의 인터페이스를 강조한다. 메세지 수신이란
  메세지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미한다.
- **메서드**: 메세지에 응답하기 위해 실행되는 코드 블록을 메서드라고 한다. 메서드는 오퍼레이션의 구현이다. 동일한 오퍼레이션이여도 메서드는 다를 수 있다.
- **퍼블릭 인터페이스:** 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메세지의 묶음.
- **시그니처**: 오퍼레이션이나 메서드이 명세를 나타낸 것으로 이름과 인자를 포함한다.

## 인터페이스와 설계 품질

- **좋은 인터페이스란?**
    1. 최소한의 인터페이스
    2. 추상적인 인터페이스
- 책임 주도 설계 방법을 따르면 좋은 인터페이스를 도출하기 쉬움

### 디미터 법칙

- **디미터 법칙**: 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙. 즉 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.

#### **디미터 법칙을 따르는 방법**

- 모든 클래스 C와 C에 구현된 모든 메서드 M이라고 한다.
- 이때 M이 메세지를 전송할 수 있는 모든 객체는 다음 조건을 갖추고 있어야 한다.
    1. this 객체 (자기 자신)
    2. 메서드의 매개변수
    3. this의 속성(필드)
    4. this의 속성인 컬렉션의 요소
    5. 메서드 내에서 생성된 지역 객체
- 디미터 법칙을 따르면 **부끄럼티는 코드**를 작성 가능
- 부끄럼타는 코드란 다른 객체에게 불필요한 어떤 것도 보여주지 않으며 다른 객체의 구현에 의존하지 않는 코드

#### 디미터 법칙이 가치 있는 이유

- 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것
- 디미터 법칙이 가치 있는 이유는 캡슐화를 위한 지침을 상세한 지침이기 때문이다.

**디미티 법칙 위배 코드**

```java
screening.getMovie().

getDiscountConditions();
```

- 위처럼 메세지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메세지를 전송하는 것을 **기차 충돌** 이라고 표현한다.
- 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 보이는 전형적인 형태

### 묻지 말고 시켜라

- 디미터 법칙은 객체의 상태에 대해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조
- **묻지 말고 시켜라** 스타일의 메세지 작성을 장려
- 묻지 말고 시켜라 스타일로 코드를 작성하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고, 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.
- **현재 있는 오퍼레이션 중 소통하는 상대 객체의 상태를 묻는 오퍼레이션이 있다면 더 나은 방법이 없는지 고민해보자**

#### 디미터 법칙에 대해

- 호출하는 객체는 이웃 객체가 수행하는 역할을 활용하여 무엇을 원하는지를 서술해야 한다.
- 그리고 호출되는 객체가 처리하는 것은 자유롭게 하도록 해야 한다.

### 의도를 드러내는 인터페이스

- 메서드의 이름을 지을 때는 **무엇을 하느냐**에 초점을 맞춰야 한다.
- 무엇을 하느냐에 초점을 맞추면 클라이언트 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.
- 이렇게 무엇을 하냐느에 따라서 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자 패턴**이라고 한다.
- 의도를 드러내는 선택자를 인터페이스 레벨로 확장한다면 **의도를 드러내는 인터페이스**
- 의도를 드러내는 인터페이스는 구현과 관련된 정보는 모두 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것

## 원칙의 함정

- 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것

### 디미터 법칙은 하나의 도트(.)를 강제하는 것이 아니다.

```java
IntStream.of(1,15,20,3,9)
    .

filter(x ->x >10)
        .

distinct()
    .

count();
```

- 위 코드는 디미터 법칙을 위반하는 것일까?
- 만약 위반한다고 생각한다면 디미터 법칙을 잘못 이해하고 있다.
- 위 코드에서 `of(), filter(), distinct()`는 모두 `IntStream` 인스턴스를 반환한다.
- 디미터 법칙은 결합도와 관련된 것인데 **결합도가 문제되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정한다.**
- 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 것이다.
- 🤔: 여러 개의 도트를 사용하고 있는 데 이 코드가 객체 내부 구조를 노출하는 가?

### 결합도와 응집도의 충돌

- 일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변경하는 코드라면 **묻지 말고 시켜라 스타일로 변경해야 한다.**
- 하지만 너무 맹목적으로 바꾼다면 응집도가 너무 낮은 객체가 될 수 있다.
- 설계는 트레이드 오프의 산물이다. 소프트웨어 설계에 존재하는 법칙 중 하나는 "경우에 따라 다르다." 라는 사실을 명심하자.

## 명령-쿼리 분리 원칙

- 객체에게 시키는 것은 항상 가능한 것이 아니다. 가끔씩은 물어봐야 한다
- 가끔씩은 필요에 따라 물어봐야 한다는 사실에 납득했다면 **명령-쿼리 분리 원칙**을 알면 된다.

#### 명령-쿼리 분리 원칙의 이해를 돕는 용어

- **루틴**: 어떤 절차를 묶어서 호출 가능하도록 이름을 부여한 기능 모듈, 루틴은 프로시저와 함수로 구분된다. (구분은 반환값의 유무)
- **프로시저**: 루틴의 한 종류이며 정해진 절차에 따라서 내부 상태를 변경하는 것 (부수효과 발생 가능성 O)
- **함수**: 루틴의 한 종류이며 어떤 절차에 따라서 필요한 값을 계산해서 반환하는 것 (부수효과 발생 가능성 X)

#### 명령(Command)과 쿼리(Query)

- 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름
- **명령:** 객체의 상태를 수정하는 오퍼레이션 (프로시저와 동일)
- **쿼리:** 객체와 관련된 정보를 반환하는 오퍼레이션 (함수와 동일)
- 명령과 쿼리를 분리하는 것의 요지는 **부수효과를 발생시키는가?** 이다.
- **명령은 반환값을 가져서는 안된다.**
- **쿼리는 상태를 변경할 수 없다.**
- 명령-쿼리 분리 원칙에 의해 작성된 객체의 인터페이스를 **명령-쿼리 인터페이스** 라고 부른다.

### 명령-쿼리 분리와 참조 투명성

- **참조 투명성:** 어떤 표현식 `e`가 있을 때 `e`의 값으로 모든 위치를 교체하더라도 달라지지 않는 특성
- **불변성:** 부수효과가 발생하지 않는 성질

#### 명령형 프로그래밍과 함수형 프로그래밍

- **명령형 프로그래밍:** 부수 효과를 기반으로 하는 프로그래밍 방식
    - 상태를 변경시키는 연산들을 순서대로 나열
- **함수형 프로그래밍:** 부수 효과가 존재하지 않는 수학에서의 함수에 기반한다. 참조 투명성의 장점이 극대화 돼서 결과를 예측하기가 쉽다.

### 책임에 초점을 맞춰라

#### 원칙들의 긍정적 영향

- **디미터 법칙:** 협력이라는 컨텍스트 안에서 객체보다 메세지를 먼저 결정하면 두 객체 사이의 구조적 결합도를 낮출 수 있다. 수신할 객체를 알지 못한 상태에서 메세지를 먼저 선택하기 때문에 객체의 내부 구조에
  대해서 고민할 필요가 없어진다. 따라서 메세지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.
- **묻지 말고 시켜라:** 메세지를 먼저 선택한다면 묻지 말고 시켜라 스타일에 따라서 협력을 구조화하게 된다. 클라이언트의 관점에서 메세지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한
  메세지를 전송하면 된다.
- **의도를 드러내는 인터페이스:** 메세지를 먼저 선택한다는 것은 클라이언트의 관점에서 메세지의 이름을 정하는 것이다. 클라이언트가 정하기 때문에 당연히 의도가 드러날 수 밖에 없다.
