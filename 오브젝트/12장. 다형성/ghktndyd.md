# 12. 다형성

## 다형성

**컴퓨터 과학에서의 다형성**: 하나의 추상 인터페이스에 대해 코드를 작성하고, 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력

**객체 지향 프로그래밍에서의 다형성 분류**
![[Pasted image 20240620133121.png]]

- **오버로딩 다형성:** 하나의 클래스 안에 동일한 이름의 메서드가 존재
- **강제 다형성**: 언어가 지원하는 자동 타입 변환이나 사용자가 직접 구현한 타입 변환으로 연산자를 다양한 타입에 사용할 수 있는 방식
- **매개변수 다형성**: 제네릭 프로그래밍과 관련이 있다. 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언하고 사용 시점에 구체적인 타입으로 지정하는 방식
- **포함 다형성**: 메세지가 동일하더라도 수신한 객체의 타입에 따라서 수행하는 행동은 달라지는 것이고 가장 일반적으로 다형성을 말한다면 포함 다형성을 뜻함

## 상속의 양면성

- 상속의 목적은 코드 재사용이 아니고, 다형성을 가능하게 하는 타입 계층 구축이 목적임
- **메서드 오버라이딩:** 부모 클래스의 메서드와 동일한 메서드 시그니처를 가진 메서드를 재정의하여 새로운 구현으로 대체하는 것

### 데이터 관점의 상속

- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것
- 따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스의 인스턴스 변수를 모두 포함 가능

### 행동 관점의 상속

- 해동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것 (JAVA는 private은 상속이 안 된다.)

## 업캐스팅과 동적 바인딩

### 같은 메세지, 다른 메서드

- **업캐스팅:** 부모 클래스 타입으로 선언된 변수에 자식 클래스 인스턴스를 할당하는 것
- **동적 바인딩:** 선언된 변수의 타입이 아니라 메세지를 수신하는 객체의 타입에 따라서 실행되는 메커니즘
  (컴파일 시점에 메서드를 정하는 게 아니라 런타임 시점에 메서드를 정하기 때문에 이것이 가능하다.)

> [!note] **개방-폐쇄 원칙과 의존성 역전 원칙**
> 업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 실행되는 메서드를 변경 가능하도록 해줌
> 업캐스팅과 동적 메서드 탐색은 OCP의 목적을 이룰 수 있게 해주는 방법

### 업캐스팅

- 자식 클래스가 부모 클래스를 사용할 때는 명시적으로 타입 변환을 해주지 않아도 가능 이것이 업캐스팅
- 부모 클래스가 자식 클래스를 사용할 때는 명시적인 타입 변환을 해줘야 한다. 이것은 다운캐스팅

### 동적 바인딩

- 전통적인 언어의 함수 실행 방법은 함수 호출이며 컴파일타임에 함수가 결정된다.
- **정적 바인딩:** 컴파일 타임에 호출할 함수가 정해지는 거

- 객체지향 언어의 메서드 실행 방법은 메세지 전송이며 런타임에 메서드가 결정된다.
- **동적 바인딩:** 런타임에 실행될 메서드를 결정하는 방식

## 동적 메서드 탐색과 다형성

**객체지향 시스템에서 실행할 메서드를 결정하는 방법**

1. 메세지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 확인한다. 존재하면 메서드를 실행하고, 탐색을 종료한다.
2. 메서드를 찾지 못 했다면 부모 클래스에서 메서드 탐색을 계속한다. 이 과정을 메서드를 찾을 때까지 상속 계층을 계속 올라가면서 반복한다.
3. 상속 계층의 최상위 클래스에 도착했는데도 메서드가 없다면 예외를 발생시키며 탐색을 중단한다.

#### self 참조

- 객체가 메세지를 수신하면 컴파일러는 `self` 라는 참조 임시변수를 자동으로 생성한다.
- 그리고 `self`가 메세지를 수신한 객체를 가르키도록 설정한다.
- 동적 메서드 탐색은 `self`가 가르키는 객체부터 상속의 역방향(자식에서 부모로)으로 이뤄진다.
- 만약 메서드 탐색이 종료된다면 `self` 참조는 자동으로 소멸한다.
- 자바에서는 `this` 키워드로 `self`를 대신한다.

#### 동적 메서드 탐색의 원리

1. **자동적인 메세지 위임**
   자식 클래스는 자신이 이해 못하는 메세지를 수신할 경우 부모 클래스에게 처리를 위임한다. 이때 클래스 사이의 위임은 개발자가 전혀 상관하지 않는다.
2. **동적인 문맥**
   메세지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 런타임에 이뤄지며 메서드를 탐색하는 경로는 `self` 참조를 이용

### 자동적인 메세지 위임

- 동적 메서드 탐색 입장에서 상속 계층은 메서드 탐색 경로를 정의하는 것

### 동적인 문맥

- `lecture.evaluate()`라는 메세지 전송 코드만 보고 어떤 클래스의 어떤 메서드가 실행될 지를 파악할 수 없다.
- 왜냐하면 저 메세지를 수신하는 객체가 무엇인지에 따라서 문맥이 동적으로 바뀌기 때문이다.
- 동적인 문맥을 결정하는 것이 `self 참조`이다.

### 이해할 수 없는 메세지

- 정적 타입 언어에서는 상속 계층 전체를 탐색했을 때 처리 가능한 메세지를 발견하지 못 한다면 컴파일 에러를 발생시킴
- 동적 타입 언어에서는 컴파일 단계가 존재하지 않기에 실제로 코드를 실행하기 전까지는 메세지 처리 가능 여부를 판단할 수 없다.

### self 대 super

- `self 참조`: 동적
- `super 참조`: 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용
- `super 참조`의 용도: "지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요" 라는 뜻

## 상속 대 위임

- 다형성은 `self 참조`가 가리키는 현재 객체에게 메세지를 전달하는 특성을 기반으로 함

### 위임과 self 참조

- 자식 클래스의 인스턴스는 내부에 부모 클래스의 인스턴스를 포함한다.
- 위와 같은 경우에 `self 참조`는 당연히 자기 자신이다.
- 그렇다면 자식 인스턴스 내부에 포함된 부모 인스턴스의 `self 참조는` 무엇일까?
- 위 경우에도 자식 인스턴스다.

> [!note] **포워딩과 위임**
> 객체가 다른 객체에게 요청을 처리할 때 `self`로 전달하지 않을 수 있다.
> 위와 같은 상황은 요청을 전달받은 최초 객체에게 다시 메세지를 전송할 필요는 없고 단순히 코드를 재사용하고 싶은 경우이다. 이처럼 `self 참조`를 전달하지 않는 경우를 **포워딩**이라고 한다.
> 반대로 `self 참조`를 전달한다면 이는 **위임**이라고 한다. **위임의 용도는** 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것이다.

### 프로토타입 기반의 객체지향 언어

- 클래스가 없고 객체만 존재하는 프로토타입 기반의 객체지향 언어에서는 상속을 구현하는 방법이 객체 사이의 위임을 이용하는 것이다.
- 프로토타입 기반 객체지향 언어는 객체 사이의 자동적인 메세지 위임을 통해서 상속을 구현함. 상속은 정적인 관계로만 구현되는 것이 절대 아님.