# 서브 클래싱과 서브 타이핑

**상속의 용도**

1. 타입 계층 구현
    - 일반적으로 부모 클래스는 일반적인 개념 구현 (자식 클래스의 일반화)
    - 자식 클래스는 특수한 개념을 구현 (부모클래스의 특수화)
2. 코드 재사용
    - 상속은 간단하게 부모 클래스의 코드를 재사용할 수 있음
    - 하지만 부모 클래스와 강하게 결합됨

위와 같은 이유때문에 상속의 제 1목표는 타입 계층 구현이어야 한다. (동일한 메세지 요청, 각기 다른 응답)

> [!note] 객체지향 프로그래밍과 객체기반 프로그래밍
> - **객체기반 프로그래밍:** 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성
    > 위 정의에 따르면 **객체지향 프로그래밍** 역시 객체기반 프로그래밍의 한 종류다.
> - **객체지향 프로그래밍:** 객체기반 프로그래밍 + 상속 + 다형성

## 타입

### 개념 관점의 타입

- **개념 관점의 타입:** 우리가 인지하는 세상의 사물의 종류 (EX) 자바, C, 파이썬은 프로그래밍 언어 타입
- **인스턴스:** 어떤 대상이 타입으로 분류될 때 그 대상을 부르는 단어
- **객체:** 일반적으로 타입의 인스턴스

**타입의 구성**

- **심볼:** 타입에 이름을 붙인 것
- **내연:** 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
- **외연:** 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입

- **프로그래밍 언어 관점의 타입:** 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙

**프로그래밍 언어에서의 타입의 목적**

- 타입에 수행될 수 있는 오퍼레이션의 집합 정의
    - Ex) 자바에서 `+` 연산자는 원시 숫자 타입이나 문자열 타입에서는 사용 가능하지만 다른 타입에서는 사용 불가능
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
    - Ex) 자바에서 `a + b`를 할 때 `a`와 `b`가 숫자형이라면 두 수를 더함. 만약 문자열이라면 두 문자열을 이어 붙임

### 객체지향 패러다임 관점의 타입

- **객체의 타입:** 객체가 수신할 수 있는 메세지의 종류를 정의하는 것
- 객체가 수신할 수 있는 메세지의 집합? ✅ **퍼블릭 인터페이스**
- **객체지향 패러다임 관점의 타입:** 객체의 퍼블릭 인터페이스를 정의하는 것, 그렇기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체는 동일한 타입
  📝: 여태까지의 내용상 보면 객체에게 중요한 게 속성이 아니라 행동임을 알 수 있음. 동일한 속성이여도 퍼블릭 인터페이스가 다르면 다른 타입이다. **동일한 속성이 아니여도 동일한 퍼블릭 인터페이스를 공유한다면
  동일한 타입이다.**

## 타입 계층

### 타입 사이의 포함관계

- 타입은 다른 타입을 포함할 수 있다.
- 여기서 포함하는 타입은 포함되는 타입에 비해 일반화된 의미를 표현할 수 있다. (포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 작음)
- 포함되는 타입은 좀 더 특수하고 구체적인 의미를 표현할 수 있다. (포함되는 타입은 외연 관점에서는 작고, 내연 관점에서는 더 특수함)
- 더 일반적인 타입은 **슈퍼타입**
- 더 구체적인 타입은 **서브타입**

> [!note] 일반화와 특수화의 정의
> - **일반화**는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
> - **특수화**는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

**슈퍼타입의 특징**

- 슈퍼타입의 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 더 일반적이다.

**서브타입의 특징**

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

- **슈퍼타입:** 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
- **서브타입:** 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜서 상대적으로 구체적이고 좁은 의미로 정의한 것
- 기준은 **퍼블릭 인터페이스**이며 서브타입의 인스턴스는 슈퍼타입의 인스턴스기도 하다. (이것이 다형성의 핵심)

## 서브 클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서 타입을 구현하는 방법은 클래스를 이용하는 것
- `부모 클래스 == 슈퍼타입 역할`
- `자식 클래스 == 서브타입 역할`

### 언제 상속을 사용해야 하는가?

- 마틴 오더스키는 아래 두 가지 조건을 만족할 때 상속을 사용해야 한다고 함

1. 상속 관계가 is-a 관계를 모델링하는가?
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

### is-a 관계

- 펭귄은 새다.
- 새는 날 수 있다.

위 그렇다면 펭귄은 새의 서브 타입이 될 수 있나? 될 수 없음
왜냐면 펭귄은 새지만 날 수 없음. 그렇기 때문에 is-a 여도 상속하면 안 될 수도 있음

### 행동 호환성

- 행동이 호환될 경우에는 타입 계층으로 묶어야 함. (위 펭귄 예시)
- 행동의 호환 여부 판단은 **클라이언트의 관점으로 진행**

### 클라이언트의 기대에 따라 계층 분리하기

![[Pasted image 20240622080519.png]]

- 위처럼 날 수 있는 새와 날 수 없는 새를 인터페이스로 분리
- 더 좋은 방법은 합성을 사용하는 것
- 만약 그림상 Client1의 기대가 바뀌어서 Flyer의 인터페이스가 변경돼도 Bird만 영향을 받는다. Client2는 수정해야 될 게 없다. 이처럼 클라이언트의 기대에 따라 분리하는 설계 원칙을 **인터페이스
  분리 원칙 (ISP)** 라고 부른다.
- 중요한 것은 **요구사항 속에서 클라이언트가 기대하는 행동에 따라서 분리하는 것**이다.

### 서브 클래싱과 서브 타이핑

- **서브 클래싱:** 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우 (구현 상속)
- **서브 타이핑**: 타입 계층을 구성하기 위해서 상속을 사용하는 경우 (인터페이스 상속)
- **상속은 서브 타이핑을 목적으로 사용돼야 한다.**
    1. 서브 타입이 슈퍼타입의 모든 행동을 동일하게 할 수 있어야 한다. (행동 호환성 만족)
    2. 자식 클래스와 부모 클래스 사이의 행동 호환성이 만족한다는 것은 부모 클랴스에 대한 자식 클래스의 대체 가능성이다. (새로운 자식 클래스가 추가 돼도 시스템이 문제 없이 동작하는 것을 보장해야 함)

## 리스코프 치환 원칙

> 서브 타입은 그것의 기반 타입에 대해 대체 가능해야 한다. 즉 클라이언트가 기반 클래스의 인터페이스를 통해서 서브 클래스를 사용할 수 있어야 한다.

### 클라이언트와 대체 가능성

- `직사각형`은 `정사각형`이다?
    - 직사각형은(Rectangle)은 너비와 높이가 다르다.
    - 정사각형은 (Square)는 너비와 높이가 항상 같다.
    - 클라이언트는 너비와 높이가 다르다는 가정하에 개발된 클라이언트 코드에서 직사각형을 정사각형을 대체할 경우 직사각형의 규칙을 위반할 가능성이 높다.
- `Stack`과 `Vector`
    - 스택은 임의의 위치에서 조회나 추가를 금지한다.
    - 벡터는 임의의 위치에 요소를 추가하거나 추출하는 것이 가능하다.
    - 하지만 스택은 백터의 자식 클래스이므로 백터의 행동들도 할 수 있다.
    - 만약 클라이언트가 스택에서 백터의 행동을 해버린다면 스택의 규칙이 위반된다.

✅ **대체 가능성을 결정하는 것은 클라이언트인 것을 기억하기**

### is-a 관계 다시 살펴보기

- 어휘적으로 is-a 관계라고 말할 수 있더라도 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 is-a 관계가 아니다.
- is-a 관계는 객체지향 개발에서 중요한 것은 객체의 속성이 아니라 행동임을 강조

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 리스코프 치환 원칙은 어떤 자식 클래스와도 안정적으로 협력 가능한 상속 구조를 구현한다.
- 자식 클래스가 클라이언트 관점에서 부모 클래스를 대체 가능하다면 기능 확장을 위해서 자식 클래스를 추가해도 다른 코드들을 수정할 필요가 없다.
- 즉 리스코프 치환 원칙은 OCP의 전제 조건이다.

### 타입 계층과 리스코프 치환 원칙

- 상속 없이도 서브 타이핑 관계를 구현할 수 있다.
- 대신 리스코프 원칙을 준수해야만 서브 타이핑 관계라고 말할 수 있다.
- 핵심은 클라이언트의 관점에서 슈퍼 타입에 기대하는 것이 서브 타입에도 적용돼야 한다는 것

## 계약에 의한 설계와 서브 타이핑

- **계약에 의한 설계:** 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점으로 표현하는 것

**계약에 의한 설계 구성 요소**

1. 사전 조건    ```

```java
// screening을 받기 전에 사전 조건
assert acreening !=null&&screening.

getStartTime().

isAfter(LocalDateTime.now());
```

- screening은 null이 아니어야 한다.

2. 사후 조건

```java
// 반환 값은 null이면 안 되고, 0원보다 작으면 안 되기 때문에 사후 조건
assert amount !=null&&amount.

isGreaterThanOrEqual(Money.ZERO);
```

- 반환 값은 null이 아니어야 한다.
- 반환 값은 최소한 0보다는 커야 한다.

3. 클래스 불변식

### 서브 타입과 계약

- 서브 타입에는 더 강력한 사전 조건을 정의할 수 없다.
- 서브 타입에 슈퍼타입과 같거나 더 약한 사건조건은 정의할 수 있다.
- 서브 타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브 타입에 슈퍼타입보다 약한 사후조건을 정의할 수 없다.

