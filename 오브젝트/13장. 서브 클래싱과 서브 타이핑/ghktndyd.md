# 서브 클래싱과 서브 타이핑

**상속의 용도**

1. 타입 계층 구현
    - 일반적으로 부모 클래스는 일반적인 개념 구현 (자식 클래스의 일반화)
    - 자식 클래스는 특수한 개념을 구현 (부모클래스의 특수화)
2. 코드 재사용
    - 상속은 간단하게 부모 클래스의 코드를 재사용할 수 있음
    - 하지만 부모 클래스와 강하게 결합됨

위와 같은 이유때문에 상속의 제 1목표는 타입 계층 구현이어야 한다. (동일한 메세지 요청, 각기 다른 응답)

> [!note] 객체지향 프로그래밍과 객체기반 프로그래밍
> - **객체기반 프로그래밍:** 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성
    > 위 정의에 따르면 **객체지향 프로그래밍** 역시 객체기반 프로그래밍의 한 종류다.
> - **객체지향 프로그래밍:** 객체기반 프로그래밍 + 상속 + 다형성

## 타입

### 개념 관점의 타입

- **개념 관점의 타입:** 우리가 인지하는 세상의 사물의 종류 (EX) 자바, C, 파이썬은 프로그래밍 언어 타입
- **인스턴스:** 어떤 대상이 타입으로 분류될 때 그 대상을 부르는 단어
- **객체:** 일반적으로 타입의 인스턴스

**타입의 구성**

- **심볼:** 타입에 이름을 붙인 것
- **내연:** 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
- **외연:** 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입

- **프로그래밍 언어 관점의 타입:** 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙

**프로그래밍 언어에서의 타입의 목적**

- 타입에 수행될 수 있는 오퍼레이션의 집합 정의
    - Ex) 자바에서 `+` 연산자는 원시 숫자 타입이나 문자열 타입에서는 사용 가능하지만 다른 타입에서는 사용 불가능
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
    - Ex) 자바에서 `a + b`를 할 때 `a`와 `b`가 숫자형이라면 두 수를 더함. 만약 문자열이라면 두 문자열을 이어 붙임

### 객체지향 패러다임 관점의 타입

- **객체의 타입:** 객체가 수신할 수 있는 메세지의 종류를 정의하는 것
- 객체가 수신할 수 있는 메세지의 집합? ✅ **퍼블릭 인터페이스**
- **객체지향 패러다임 관점의 타입:** 객체의 퍼블릭 인터페이스를 정의하는 것, 그렇기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체는 동일한 타입
  📝: 여태까지의 내용상 보면 객체에게 중요한 게 속성이 아니라 행동임을 알 수 있음. 동일한 속성이여도 퍼블릭 인터페이스가 다르면 다른 타입이다. **동일한 속성이 아니여도 동일한 퍼블릭 인터페이스를 공유한다면
  동일한 타입이다.**

## 타입 계층

### 타입 사이의 포함관계

- 타입은 다른 타입을 포함할 수 있다.
- 여기서 포함하는 타입은 포함되는 타입에 비해 일반화된 의미를 표현할 수 있다. (포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 작음)
- 포함되는 타입은 좀 더 특수하고 구체적인 의미를 표현할 수 있다. (포함되는 타입은 외연 관점에서는 작고, 내연 관점에서는 더 특수함)
- 더 일반적인 타입은 **슈퍼타입**
- 더 구체적인 타입은 **서브타입**

> [!note] 일반화와 특수화의 정의
> - **일반화**는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
> - **특수화**는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

**슈퍼타입의 특징**

- 슈퍼타입의 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 더 일반적이다.

**서브타입의 특징**

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

- **슈퍼타입:** 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
- **서브타입:** 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜서 상대적으로 구체적이고 좁은 의미로 정의한 것
- 기준은 **퍼블릭 인터페이스**이며 서브타입의 인스턴스는 슈퍼타입의 인스턴스기도 하다. (이것이 다형성의 핵심)

## 서브 클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서 타입을 구현하는 방법은 클래스를 이용하는 것
- `부모 클래스 == 슈퍼타입 역할`
- `자식 클래스 == 서브타입 역할`

### 언제 상속을 사용해야 하는가?

- 마틴 오더스키는 아래 두 가지 조건을 만족할 때 상속을 사용해야 한다고 함

1. 상속 관계가 is-a 관계를 모델링하는가?
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

### is-a 관계

- 펭귄은 새다.
- 새는 날 수 있다.

위 그렇다면 펭귄은 새의 서브 타입이 될 수 있나? 될 수 없음
왜냐면 펭귄은 새지만 날 수 없음. 그렇기 때문에 is-a 여도 상속하면 안 될 수도 있음

### 행동 호환성

- 행동이 호환될 경우에는 타입 계층으로 묶어야 함. (위 펭귄 예시)
- 행동의 호환 여부 판단은 **클라이언트의 관점으로 진행**
- 450page부터 읽기