# 02. 객체지향 프로그래밍

### 협력, 객체, 클래스

- 객체지향 설계는 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요하는지 고민하는 것이 아니다.
- **객체지향 프로그래밍을 제대로 하려면**

1. 어떤 객체들이 필요한지 고민하라. (클래스 != 객체)
2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 보자.

### 도메인의 구조를 따르는 프로그램 구조

- **도메인**: 문제를 해결하기 위해서 사용자가 프로그램을 사용하는 분야
- 도메인의 개념과 관계를 반영해서 프로그램을 구조화해야 한다.
- 이 말은 클래스의 구조는 도메인의 관계들과 유사해야 한다는 말 같음.

### 클래스 구현하기

- 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것
- 이 말은 private와 public 등 접근제어자를 잘 사용해야 한다는 말 같음.

##### 그렇다면 왜 내부와 외부를 구분하는 게 중요할까?

- 경계의 명확성이 객체의 자율성을 보장한다.
  객체가 자율적이려면 내부는 감추고 외부는 인터페이스로만 소통해야 한다.
- 프로그래머에게 구현의 자유를 제공한다.
  내부 구현 변경으로 인해 클라이언트 코드에 끼치는 영향을 걱정하지 않아도 된다.

#### 정리

- 객체 내부에 대한 접근을 통제할 수 있는 접근 제어 매커니즘이 존재한다. 자바는 접근 제어자를 제공한다.
- 접근을 통제하는 이유는 자율적인 존재로 만들기 위해서이다. 왜냐하면 외부에서 접근이 허용되면 객체는 자신의 상태를 외부의 개입에 의해 변경해야 하는 경우가 생길 수 있다.
- 하지만 외부에서 접근해야 하는 경우도 있다. 이럴 때 제공하는 **퍼블릭 인터페이스**
- 외부에서 접근이 불가능한 객체의 다른 요소를 **구현**
- **인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그래밍을 위한 핵심**

### 협력하는 객체들의 공동체

- 시스템이 제공하는 기능을 구현하기 위해서 객체들 사이에 이뤄지는 상호작용을 협력이라고 한다.
- 객체지향 프로그램을 작성할 때는 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해서 클래스를 작성한다.

### 협력에 관한 짧은 이야기

- 객체의 내부는 외부에서 접근하지 못 하도록 해야 한다.
- 대신 외부에 공개된 퍼블릭 인터페이스를 통한다면 접근이 가능하다.
- 객체는 다른 객체의 **퍼블릭 인터페이스를 통해서 공개된 행동을 수행하도록 요청할 수 있다.**
- 요청을 받은 객체는 자신의 자율적인 방법으로 요청을 처리한 후 **응답한다.**
- 객체가 다른 객체와 **상호작용할 수 있는 유일한 방법은 메세지를 전송하거나 수신하는 것**이다. (그렇다면 전송하는 것이 요청이고, 수신하는 것이 응답일까? 🚀)
- 메세지 처리를 위한 자율적인 방법을 **메서드** 라고 한다.

### 할인 정책

- 할인 정책은 금액 할인 정책과 비율 할인 정책으로 구분된다.
- 두 클래스는 대부분 코드가 유사하고, 할인을 얼만큼 해줄지 계산하는 방식만 조금 다르다.
- 따라서 두 클래스 사이의 중복 코드 제거를 위한 공통 코드 보관소가 필요하다.
- 이는 **추상 클래스**로 구현 가능하다. (추상 클래스가 공통 코드 보관소)
- 그렇다면 추상 클래스인 할인 정책을 금액 할인 정책과 비율 할인 정책 클래스가 상속받아서 오버라이딩 해야할 것이다.
- 이렇게 부모 클래스에서 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 **TEMPLATE METHOD 패턴**이라고 한다.

### 의존성

- 어떤 클래스가 **다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재**한다고 한다.

### 컴파일 시점 의존성과 런타임 시점 의존성

- 컴파일 시점과 런타임 시점에서는 의존성이 다를 수 있다.
- 코드에서는 **Movie**는 **추상 클래스인 DiscountPolicy**를 의존한다.
- 하지만 런타임 시점에서는 **Movie**는 **DiscountPolicy의 자식 클래스**들에 의존한다.
- 이 말은 클래스의 의존성과 객체의 의존성을 동일하지 않을 수 있다는 것이다.
- 이처럼 클래스 사이의 의존성과 객체 사이의 의존성이 동일하지 않다면 코드를 이해하기 어려워진다. 반면 코드는 유연해지며 확장 가능성이 좋아진다. (**트레이드 오프의 산물**)

### 차이에 의한 프로그래밍

- 상속은 객체지향에서 코드를 재사용하기 위한 방법이다.
- 상속을 통해서 클래스 사이에 관계를 설정해줌으로서 기존 클래스의 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.

### 상속과 인터페이스

- 인터페이스는 객체가 이해할 수 있는 메세지의 목록을 정의하는 것이다.
- 상속을 통해서 자식 클래스는 부모 클래스의 인터페이스를 자신에게 포함하게 된다.
- 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있기 때문에 외부 객체는 부모 클래스와 자식 클래스를 동일한 타입으로 간주할 수 있다.
- 만약 이때 자식 클래스가 부모 클래스를 대신한다면 이를 **업캐스팅**이라고 한다.

### 다형성

- 메세지와 메서드는 다르다.
- **Movie**가 **DiscountPolicy**에게 **할인 금액을 계산해줘** 라는 메세지를 전송한다.
- 이때 실행되는 메서드는 **협력하는 객체가 무엇이냐에 따라서 달라진다.**
- 이처럼 동일한 메세지를 수신했을 때 객체마다 다르게 응답할 수 있는 능력을 **다형성**이라고 한다.

##### 다형성을 구현하는 방법

- 다형성을 구현하기 위한 방법은 메세지에 응답하기 위해 실행할 메서드를 런타임 시점에 결정하는 것이다.
- 메세지 응답을 위해서 메서드를 런타임 시점에 결정하는 것을 **지연 바인딩, 동적 바인딩**이라고 한다.
- 컴파일 시점에 결정하는 것을 **초기 바인딩, 정적 바인딩**이라고 한다.

#### 구현 상속과 인터페이스 상속

- 코드 재사용이 목적이면 **구현 상속**
- 다형성을 활용한 협력이 목적이면 **인터페이스 상속**
- **인터페이스 상속을 사용해야 한다 .**

### 추상화의 힘

1. 세부적인 내용을 무시하고 상위 정책을 쉽고 간단하게 표현이 가능하다.

- 이런 특징은 세부 사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다.

2. 필요에 따라서 표현의 수준을 조정하는 것이 가능하다.
3. 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

### 코드 재사용

- 코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이다.
- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.

#### 코드 재사용이 목적인 구현 상속의 문제점

- 구현 상속은 캡슐화를 위반한다.
  상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 이는 부모 클래스와 자식 클래스가 강하게 결합되도록 한다.
- 구현 상속은 설계가 유연하지 않다.

#### 코드 재사용이 목적이라면 합성을

- 합성은 위 상속의 두 가지 문제점을 모두 해결한다.
- 인터페이스에 정의된 메세지만을 재사용하기에 캡슐화가 가능하다. (인터페이스는 공개된 것이므로 내부 구현과 관련 X)
- 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽다.
- 따라서 **코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 좋다.**

### 결론

- 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 적절한 객체에게 적절한 책임을 할당하는 것이다.
