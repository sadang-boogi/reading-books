# 2. 네트워크

## 2.1 네트워크의 기초

네트워크는 노드(node)와 링크(link)가 서로 연결되어 리소스를 공유하는 집합을 의미

여기서 노드는 서버, 라우터, 스위치 같은 네트워크 장치
여기서 링크는 유선 또는 무선

### 처리량과 지연 시간

좋은 네트워크의 조건

- 많은 처리량
- 짧은 지연 시간
- 적은 장애 빈도
- 좋은 보안

**처리량 (throughput)**

- 링크 내에서 성공적으로 전달한 데이터의 양, 얼만큼의 트래픽을 처리했는지에 대한 지표
- 단위는 bps(bits per second) 초당 비트 수
- 트래픽은 특정 시점에 링크 내에 흐르는 데이터의 양

**지연 시간(latency)**

- 요청이 처리되는 시간, 어떤 메세지가 두 장치를 왕복하는 시간
- 지연 시간은 유선인지 무선인지, 패킷의 크기, 라우터의 패킷 처리 시간에 영향을 받는다.

### 2.1.2 네트워크 토폴로지와 병목 현상

#### 네트워크 토폴로지

- 네트워크의 연결 형태

**트리 토폴로지**

- 트리 모양의 계층형
- 노드의 추가, 삭제가 쉬움
- 특정 노드에 트래픽 집중이 심할 때 하위 노드에 영향

**버스 토폴로지**

- 중앙 통신 회선 하나에 여러 개의 노드가 연결된 형태
- 근거리 통신망(LAN)에서 사용
- 설치 비용이 적고, 신뢰성이 우수하며 노드의 추가, 삭제가 쉽다
- 스푸핑이 가능한 위험성도 있다.

> 스푸핑: LAN 상에서 *스위칭* 기능을 마비시키거나 속여서 악의적인 노드에 해당 패킷이 오도록 처리하는 것
> 여기서 *스위칭*은 송신부의 패킷이 수신부와 관련 없는 호스트에 가지 않도록 하는 기능

**스타 토폴로지**

- 중앙 노드에 다른 노드가 연결된 형태
- 노드를 추가하거나 에러를 탐지하기 쉽다.
- 패킷 충돌 발생 가능성도 적다.
- 중앙 노드에 장애가 발생시 전체 네트워크에 영향이 간다.

**링형 토폴로지**

- 각각의 노드가 양 옆의 노드와 연결되어 고리의 형태를 띄는 토폴로지
- 노드 수가 증가되어도 손실이 거의 없고, 충돌 가능성이 적다.
- 네트워크의 구성 변경이 어렵다

**메시 토폴로지**

- 그물망처럼 연결된 구조
- 한 단말 장치에서 장애가 발생해도 여러 개의 경로가 존재하므로 영향이 적다
- 노드의 추가가 어렵고, 운영 비용이 고가

#### 병목 현상

- 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해서 제한받는 현상

**병목 현상의 주된 원인**

- 적은 대역폭
- 네트워크 토폴로지
- 서버 CPU, 메모리 사용량
- 비효율적인 네트워크 구성

### 2.1.3 네트워크 분류

- LAN : 개인 규모의 근거리 통신망
- MAN: 도시 규모의 중거리 통신망, LAN보다 복잡
- WAN: 세계 규모의 장거리 통신망, 제일 복잡

### 2.1.4 네트워크 성능 분석 명령어

**ping**

- 확인하고자 하는 일정 노드에 패킷을 전송하는 명령어
- TCP/IP 프로토콜의 ICMP 프로토콜로 동작하기에 ICMP를 지원하지 않는다면 사용 불가능

**netstat**

- 접속되어 있는 서비스들의 네트워크 상태를 확인하는 명령어
- 주로 서비스의 포트가 열려있는지를 확인할 때 사용

**nslookup**

- DNS 관련 내용을 확인할 때 사용하는 명령어
- 특정 도메인에 매핑된 IP 확인할 때 사용

**tracert**

- Linux에서는 traceroute
- 목적지 노드까지의 노드들 중에서 어느 구간에서 응답이 느려지는지를 확인할 때 사용

## 2.2 TCP/IP 4계층 모델

- 인터넷 프로토콜 스위트: TCP/IP 4계층, OSI 7계층처럼 프로토콜의 집합을 지칭하는 단어

### 2.2.1 계층 구조

![[스크린샷 2024-08-25 오후 10.29.19.png]]

- 계층별 영향을 주지 않는다.

**애플리케이션 계층**

- 응용 프로그램이 사용되는 계층
- FTP, HTTP, SSH, SMTP, DNS 등의 많은 프로토콜 존재

**전송 계층**

- 송신자와 수신자를 연결하는 통신 서비스 제공
- 연결지향 데이터 스트림지원, 신뢰성, 흐름 제어
- TCP, UDP 등 프로토콜 존재

> TCP는 패킷의 전달 순서를 보장하고, 연결 지향형이며, 신뢰성이 좋다.
> TCP 연결시 3way handshake
> TCP 연결 해제시 4way handshake
> UDP는 순서를 보장하지 않고, 수신여부 파악을 안하고, 데이터만 준다.

**인터넷 계층**

- 패킷을 지정된 IP 주소로 전송하는 계층
- IP, ARP, ICMP 프로토콜 존재
- 비연결형

**링크 계층**

- 광섬유, 전선, 무선 등 장치 간에 신호를 주고 받는 규칙을 정하는 계층
- 물리 계층과는 약간 다름

**이더넷 프레임**

- 데이터링크 계층에서 사용되는 단위

![[스크린샷 2024-08-25 오후 10.36.24.png]]

- Preamble: 이더넷 프레임의 시작을 알리는 역할
- SFD: 다음 바이트부터 MAC 주소 필드임을 알리는 역할
- DMAC, SMAC: 수신측과 송신측의 MAC 주소
- Ether Type: IPv4인지 IPv6인지를 정의
- Payload: 실제 전달 데이터
- CRC: 에러 확인용

**계층 간 데이터 송신과 수신하는 과정**

- 송신할 때
  애플리케이션 ➡️ 전송: 세그먼트화, TCP(L4) 헤더 추가
  전송 ➡️ 인터넷: 패킷화, IP 헤더 추가
  인터넷 ➡️ 링크: 프레임화

- 수신할 때
  링크 ➡️ 인터넷: 패킷화
  인터넷 ➡️ 전송: 세그먼트화
  전송 ➡️ 애플리케이션: PDU로 전달

**PDU**

- 데이터의 한 덩어리를 뜻함. 계층마다 명칭이 다르다.
- 애플리케이션 계층: 메세지
- 전송: 세그먼트
- 인터넷: 패킷
- 링크: 프레임(데이터링크), 비트(물리)

## 2.3 네트워크 기기

### 2.3.1 네트워크 기기의 처리 범위

- 상위 계층 기기들은 하위 계층들도 처리 가능하지만 그 반대는 불가능

### 2.3.2 애플리케이션 계층을 처리하는 기기

**L7 스위치**

- 스위치는 여러 장비들과 연결되어 통신을 중재하며, 정상 목적지로만 데이터를 전송하게 하는 장비
- L7 스위치를 **로드 밸런서**라고도 하며 **로드 밸런서**는 서버의 부하를 분산시키는 역할
- 분산을 시키는 기준은 URL, 서버, 캐시, 쿠키 등등 여러가지가 있음
- 장애 발생을 검사하는 헬스 체크 기능도 제공

> **🤔: L7 스위치와 L4 스위치는 무엇이 다른가?**
> - L4 스위치는 IP와 포트 기반으로 분산 처리 (특히 포트)
>- L7 스위치는 URL, 서버, 캐시 등 여러가지 방법 다 사용
> - 클라우드 서비스에서는 아래와 같이 구분
>   - L7 로드 밸런싱을 ALB(Application Load Balancer) 컴포넌트
>   - L4 로드 밸런싱을 NLB(Network Load Balancer) 컴포넌트

### 2.3.3 인터넷 계층을 처리하는 기기

**라우터**

- 여러 개의 네트워크를 연결, 분할, 구분시키는 역할
- 라우팅을 하는 장비

> **라우팅**: 다른 네트워크와 통신할 때 패킷 소모 최적화, 경로를 최적화하는 기능

**L3 스위치**

- 사실상 라우터

### 2.3.4 데이터 링크 계층을 처리하는 기기

**L2 스위치**

- 장치들의 MAC 주소를 관리
- 패킷의 MAC 주소를 읽고 알맞은 MAC 주소를 가진 장비로 패킷을 스위칭(스위칭은 정상 목적지로만 데이터가 가게끔 하는 기능)
- 만약 MAC 주소가 없다면 전체 전송

**브리지**

- LAN끼리 통신하도록 하는 역할
- 통신 범위 확장시 각각의 LAN으로 이루어진 통신망을 하나로 통합

### 2.3.5 물리 계층을 처리하는 기기

**NIC**

- LAN 카드라고도 부름
- MAC 주소가 존재

**리피터**

- 약해진 신호를 증폭하여 전달하는 역할
- 요즘은 사실상 안 씀

## 2.4 IP 주소

### 2.4.1 ARP

> 컴퓨터 간 통신을 정확하게 말하자면 IP 주소에서 ARP를 통해서 MAC 주소를 찾아서 MAC 주소를 기반으로 통신하는 게 맞음

- 여기서 ARP가 IP 주소를 MAC 주소로 변환해줌
- RARP도 있는데 얘는 MAC 주소를 IP 주소로 변환해줌

**ARP로 MAC 주소를 찾는 과정**

1. 장치가 ARP Request 브로드캐스트를 보낸다. (브로드캐스트는 전체 전송)
    - Ex) 얘들아 너네 중에서 120.70.80.3 IP 가진 애 있어?

2. 장치 중에서 일치하는 IP를 가진 장치가 ARP Reply 유니캐스트를 요청 장치에게 보낸다. (유니캐스트는 1:1)
    - Ex) 어? 그거 내 IP야. 내 MAC 주소는 a123d-dasd야~

### 2.4.2 홉 바이 홉 통신

- IP 주소로 통신하는 과정을 지칭하는 단어
- 통신 장치에서 라우팅 테이블의 IP를 이용해서 다음 IP로 이동하고, 또 여기서도 라우팅 테이블에서 IP를 보고 이동하면서 결국에는 최종 목적지에 도착하는 통신 과정을 뜻

**라우팅 테이블**

- 게이트웨이와 모든 목적지에 대해 도달하기 위한 정보를 포함하고 있는 테이블

**게이트웨이**

- 서로 다른 통신망, 혹은 프로토콜을 사용하는 네트워크 간의 통신을 가능케하는 관문 역할

### 2.4.3 IP 주소 체계

- IPv4: 32비트를 8비트 단위로 표현, 이때 8비트마다 .(점)을 찍어서 나눔
- IPv6: 64비트를 16비트 단위로 표현, 이때 16비트마다 .(점)을 찍어서 나눔

**클래스 기반 할당 방식**

- A, B, C, D, E 클래스로 IP 주소를 나누어서 할당하는 방식
- A, B, C는 1:1 통신용, D는 멀티캐스트용, E는 예비용
- 네트워크 첫 번째 주소는 네트워크 구별용, 마지막 주소는 브로드캐스트용
    - A 클래스라면 12.0.0.0 ~ 12.255.255.255 까지인데
    - 이때 12.0.0.0은 네트워크 구별용이라 사용 X
    - 12.255.255.255는 브로드캐스트용이라 사용 X

**DHCP(Dynamic Host Configuration Protocol)**

- IP 주소 및 통신 매개변수를 자동 할당하기 위한 프로토콜

**NAT(Network Address Translation)**

- 패킷이 라우팅 장치를 통해서 전송되는 동안 패킷의 IP 주소 정보를 수정하여 다른 주소로 매핑하는 방법
- 예를 들어서 A, B 사용자가 있는데 이 둘은 `192.168.0.XXX` 기반의 IP를 사용 중이다 (이 형태의 IP를 사설 IP라고 함)
- 그리고 NAT 기능이 있는 장치로 하나의 공인 IP를 부여 받아서 공인 IP로는 외부와 통신한다.
- 여기서 라우터가 사설 IP를 공인 IP로 변환해 주고, 그 반대의 과정도 해준다.

## 2.5 HTTP

- 애플리케이션의 프로토콜

### 2.5.1 HTTP/1.0

- 반드시 요청 하나에 하나의 연결 (이 말은 즉 요청 하나를 수행하기 위해서 반드시 3way handshake 과정이 필요하다는 뜻)
- 이 때문에 RTT 증가 (RTT는 패킷의 왕복 시간)

**RTT 증가를 해결하기 위한 방법**

- 이미지 스플리팅
- 코드 압축 (개행 문자나 빈칸 제거)
- 이미지 Base64 인코딩 (64진법으로 이뤄진 문자열로 인코딩)

### 2.5.2 HTTP/1.1

- 1.0은 매번 TCP 연결이 필요했음
- 1.1은 초기화 이후에 `keep-alive` 옵션 때문에 여러 개의 파일을 송수신이 가능함
- 단점은 HOL Blocking, 무거운 헤더 구조

> **HOL Blocking:** 첫 순서의 패킷이 도착 전까지는 나머지 패킷도 도착하지 않음

### 2.5.3 HTTP/2

- 1.1보다 지연 시간이 줄고, 응답 시간이 빨라짐
- 멀티 플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리 지원 등 많은 기능 추가됨

**멀티 플렉싱**

- 여러 개의 스트림으로 통신 (스트림은 데이터 통신로 같은 느낌으로 이해)
- 단일 연결에서도 병렬로 데이터를 처리하기 때문에 HOL Blocking 해소

**헤더 압축**

- 허프만 코딩 알고리즘 사용

> **허프만 코딩 알고리즘:** 문자열을 문자로 쪼개서 빈도가 높은 정보는 작은 비트, 빈도가 낮은 정보는 큰 비트로 표현하여 전체 데이터 표현에 필요한 비트양을 줄이는 방법


**서버 푸시**

- HTML은 CSS, JS 같은 부가 리소스도 같이 있는데 이를 HTML을 보낼 때 그냥 같이 보냄

### 2.5.4 HTTPS

- HTTP/2은 HTTPS 위에서 동작하는 프로토콜이었음
- HTTPS는 **애플리케이션 계층과 전송 계층 사이에 SSL/TLS라는 신뢰 계층을 추가한 형태**

**SSL/TLS**

- SSL이 구버전, TLS가 신버전이라고 생각하면 되는데 관례상 SSL/TLS라고 부름
- 보안 세션 기반

**보안 세션**

- 세션의 시작부터 끝까지 보안이 유지되는 세션
- SSL/TLS는 handshake 과정으로 보안 세션을 생성하고 관리

- TLS는 서버와 클라이언트가 같은 key를 공유하고 이를 기반으로 통신한다.
- 클라이언트는 서버로 `사이퍼 슈트`라는 것을 전달한다.
- 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트에서 제공 가능한 게 있는지 검사하고, 있다면 서버에서 클라이언트로 인증서를 보내면서 인증 메커니즘을 시작한다.

#### 인증 메커니즘

- CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이뤄진다.
- CA 인증서는 클라이언트에게 **공개키**를 전달하여 서버가 신뢰할 수 있다고 보장해준다.
- 이때 인증서는 서비스의 정보, 공개키, 지문, 디지털 서명 등으로 이뤄진다.

**CA 인증서를 발급받으려면**

- 자신의 사이트 정보와 공개키를 CA 인증 기관에 제출한다.
- CA는 **지문**을 사용하는 CA의 비밀키 등을 기반으로 인증서를 발급한다.

> **지문:** 공개키를 해시한 값

**HTTPS를 구축하는 방법**

1. CA 인증 기관에서 구입한 인증서로 HTTPS 서비스를 구축하는 방법
2. 서버 앞단에 HTTPS를 제공하는 로드밸런서를 배치
3. 서버 앞단에 HTTPS를 제공하는 CDN 배치

### 2.5.5 HTTP/3

- QUIC 기반의 프로토콜 (UDP 기반)
- HTTP/2에 비해서 초기 연결 시간이 감소됨
- 이는 초기 연결시에 지연 시간이 감소된 이유인데 이게 가능한 게 바로 QUIC 기반이라서 가능하다.
- QUIC는 연결에만 1RTT를 소요한다. 클라이언트가 서버에 신호를 보내주고 서버는 응답하면 끝
- 손실된 알고리즘은 서버에서 직접 수정하는 FEC 매커니즘을 사용한다.
